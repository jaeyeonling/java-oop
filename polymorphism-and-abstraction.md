# 다형성과 추상화 (Polymorphism and Abstraction)

## 다형성 (Polymorphism)

* 여러(poly) 모습(porph)을 갖는 것
* 객체지향에서는 한 객체가 여러 타입을 갖는것
  * 즉 한 객체가 여러 타입의 기능을 제공
  * 타입 상속으로 다형성 구현
    * 하위 타입은 상위 타입도 된다.



## 추상화 (Abstraction)

* 데이터나 프로세스 등을 의미가 비슷한 개념이나 의미 있는 표현으로 정의하는 과정
* 두 가지 방식의 추상화
  * 특정한 성질, 공통 성질 (일반화)
* 간단한 예
  * DB의 User 테이블: 아이디, 이름, 이메일
  * Money 클래스: 통화, 금액
  * 프린터: HP, 삼성
  * GPU: 지포스, 라데온

### 타입 추상화

* 여러 구현 클래스를 대표하는 상위 타입 도출
  * 흔히 인터페이스 타입으로 추상화
  * 추상화 타입과 구현은 타입 상속으로 연결
* 기능에 대한 의미 제공
* 구현은 제공하지 않음 
  * 어떻게 구현할지 알 수 없음
* 구현을 제공하는 클래스를 콘크리트(concrete) 클래스라고 함

### 추상 타입 사용

* 추상 타입은 구현을 감춘다.
  * 기능의 구현이 아닌 의도를 더 잘 들어낸다.
* 유연함을 가질 수 있다.
* 공통점을 도출하여 도출한 추상 타입을 사용한다.
* 사용할 대상 접근도 추상화가 가능하다.
  * Factory 등

### 추상화는 의존 대상이 변경하는 시점에

* 추상화 -> 추상 타입 증가 -> 복잡도 증가
  * 아직 존재하지 않는 기능에 대한 이른 추상화는 주의한다.
    * 잘못된 추상화 가능성, 복잡도만 증가
  * 실제 변경,확장이 발생할 때 추상화 시도

### 추상화를 잘 하려면

* 구현을 한 이유가 무엇 때문인지 생각해야 한다.

### 추상화를 안하면

##### 시간이 흘러갈수록, 기능이 추가될수록 개발 시간이 증가한다.

* 코드 구조가 길어지고 복잡해진다.
* 새로운 기능 추가시 모든 메서드에 새로운 if 블록을 추가
  * 중첩 if-else는 복잡도가 배로 증가
  * if-else가 많을수록 진척이 더딤 (신중 모드)
* 관련 코드가 여러 곳에 분산됨
  * 한 처리와 관련된 코드가 여러 메서드로 흩어진다.
* 결과적으로, 코드 가독성과 분석 속도 저하
  * 코드 추가에 따른 노동 시간 증가
  * 실수하기 쉽고 이로 인한 불필요한 디버깅 시간 증가

### 추상화를 하면

##### 추상화한 타입으로만 핵심 기능 구현 가능

##### 추상화된 코드에 코드 수정없이 확장이 가능하다.

* 이것이 바로 OCP
  * Open for Extenstion (확장엔 열려있다.)
  * Closed for Modification (수정엔 닫혀 있다.)


